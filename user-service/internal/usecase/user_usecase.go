package usecase

import (
	"context"
	"errors"
	"fmt"
	"log"
	"time"

	"github.com/golang-jwt/jwt/v5"                                                  // For JWT generation
	"github.com/zhandarbeks/petstore-final-project/user-service/internal/domain" // Adjust import path
	"github.com/zhandarbeks/petstore-final-project/user-service/internal/repository"
	// "go.mongodb.org/mongo-driver/bson/primitive" // If generating IDs here, but usually repo handles it
)

// userUsecase implements the UserUsecase interface.
type userUsecase struct {
	userRepo     repository.UserRepository
	userCache    repository.UserCache // For caching user data
	jwtSecretKey []byte               // Secret key for signing JWTs
	tokenExpiry  time.Duration        // How long tokens are valid
}

// NewUserUsecase creates a new instance of userUsecase.
func NewUserUsecase(
	repo repository.UserRepository,
	cache repository.UserCache,
	jwtSecret string,
	tokenExpiry time.Duration,
) UserUsecase {
	if jwtSecret == "" {
		log.Fatal("FATAL: JWT secret key cannot be empty for UserUsecase")
	}
	return &userUsecase{
		userRepo:     repo,
		userCache:    cache,
		jwtSecretKey: []byte(jwtSecret),
		tokenExpiry:  tokenExpiry,
	}
}

// generateJWT generates a new JWT access token for a given user.
func (uc *userUsecase) generateJWT(user *domain.User) (string, error) {
	// Create the claims
	claims := jwt.MapClaims{
		"sub": user.ID, // Subject (user ID)
		"eml": user.Email,
		"unm": user.Username,                               // Username
		"exp": time.Now().Add(uc.tokenExpiry).Unix(),       // Expiration time
		"iat": time.Now().Unix(),                           // Issued at
		"iss": "petstore-user-service",                     // Issuer
		"aud": "petstore-clients",                          // Audience
		"fnm": user.FullName,                               // Full name
	}

	// Create token
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)

	// Sign token with secret
	tokenString, err := token.SignedString(uc.jwtSecretKey)
	if err != nil {
		log.Printf("Error signing JWT token for user %s: %v", user.ID, err)
		return "", fmt.Errorf("could not generate token: %w", err)
	}

	return tokenString, nil
}

// RegisterUser handles new user registration.
func (uc *userUsecase) RegisterUser(ctx context.Context, username, email, password, fullName string) (*domain.User, string, error) {
	// Basic validation (more can be added)
	if username == "" || email == "" || password == "" || fullName == "" {
		return nil, "", errors.New("username, email, password, and full name are required")
	}
	// Consider adding email format validation, password strength validation etc.

	// Check if user already exists by email
	existingUser, err := uc.userRepo.GetUserByEmail(ctx, email)
	if err != nil && err.Error() != "user not found with this email" { // If any error other than "not found"
		log.Printf("Error checking existing user by email '%s': %v", email, err)
		return nil, "", fmt.Errorf("could not verify user existence: %w", err)
	}
	if existingUser != nil {
		return nil, "", errors.New("user with this email already exists")
	}

	// Hash the password
	hashedPassword, err := domain.HashPassword(password)
	if err != nil {
		log.Printf("Error hashing password for user '%s': %v", email, err)
		return nil, "", fmt.Errorf("could not process password: %w", err)
	}

	newUser := &domain.User{
		// ID will be generated by the repository or MongoDB itself
		Username:       username,
		Email:          email,
		HashedPassword: hashedPassword,
		FullName:       fullName,
	}
	// PrepareForCreate sets CreatedAt and UpdatedAt, called by repo.CreateUser

	createdUser, err := uc.userRepo.CreateUser(ctx, newUser)
	if err != nil {
		log.Printf("Error creating user '%s' in repository: %v", email, err)
		return nil, "", fmt.Errorf("could not register user: %w", err)
	}

	// Generate JWT token for the new user
	tokenString, err := uc.generateJWT(createdUser)
	if err != nil {
		// Log error but proceed with user creation if token generation fails.
		// Alternatively, you could make this a critical failure.
		log.Printf("Warning: User %s registered but failed to generate JWT: %v", createdUser.ID, err)
		// Depending on requirements, you might return the user without a token or error out.
		// For now, we'll return the user and an empty token with the error.
		return createdUser, "", fmt.Errorf("user registered, but token generation failed: %w", err)
	}

	log.Printf("User registered successfully: %s (ID: %s)", createdUser.Email, createdUser.ID)
	return createdUser, tokenString, nil
}

// LoginUser handles user login and JWT generation.
func (uc *userUsecase) LoginUser(ctx context.Context, email, password string) (*domain.User, string, error) {
	if email == "" || password == "" {
		return nil, "", errors.New("email and password are required")
	}

	user, err := uc.userRepo.GetUserByEmail(ctx, email)
	if err != nil {
		if err.Error() == "user not found with this email" {
			return nil, "", errors.New("invalid email or password")
		}
		log.Printf("Error fetching user by email '%s' for login: %v", email, err)
		return nil, "", fmt.Errorf("authentication failed: %w", err)
	}

	if !domain.CheckPasswordHash(password, user.HashedPassword) {
		return nil, "", errors.New("invalid email or password")
	}

	tokenString, err := uc.generateJWT(user)
	if err != nil {
		log.Printf("Error generating JWT for user %s during login: %v", user.ID, err)
		return nil, "", fmt.Errorf("login successful, but could not generate token: %w", err)
	}

	log.Printf("User logged in successfully: %s (ID: %s)", user.Email, user.ID)
	// Optionally, update LastLoginAt field here if you have one
	return user, tokenString, nil
}

// GetUserByID retrieves a user by their ID, utilizing the cache.
func (uc *userUsecase) GetUserByID(ctx context.Context, id string) (*domain.User, error) {
	if id == "" {
		return nil, errors.New("user ID is required")
	}

	// 1. Try to get from cache
	cachedUser, err := uc.userCache.GetUser(ctx, id)
	if err == nil && cachedUser != nil {
		log.Printf("User %s found in cache", id)
		return cachedUser, nil
	}
	if err != nil && err.Error() != "user not found in cache" { // Log actual cache errors
		log.Printf("Error fetching user %s from cache: %v", id, err)
	}

	// 2. If not in cache or cache error, get from repository
	log.Printf("User %s not in cache or cache error, fetching from repository", id)
	user, err := uc.userRepo.GetUserByID(ctx, id)
	if err != nil {
		log.Printf("Error fetching user %s from repository: %v", id, err)
		return nil, err // err could be "user not found" or other DB error
	}

	// 3. Set in cache for future requests
	// Use a reasonable expiration for user data, e.g., 1 hour
	cacheErr := uc.userCache.SetUser(ctx, id, user, 1*time.Hour)
	if cacheErr != nil {
		log.Printf("Warning: Failed to set user %s in cache after fetching from repo: %v", id, cacheErr)
	}

	return user, nil
}

// UpdateUserProfile handles updating a user's profile information.
// It uses pointers for username and fullName to allow partial updates (only update if provided).
func (uc *userUsecase) UpdateUserProfile(ctx context.Context, id string, username, fullName *string) (*domain.User, error) {
	if id == "" {
		return nil, errors.New("user ID is required for update")
	}
	if username == nil && fullName == nil {
		return nil, errors.New("at least one field (username or full name) must be provided for update")
	}

	// Fetch the existing user
	user, err := uc.userRepo.GetUserByID(ctx, id)
	if err != nil {
		log.Printf("Error fetching user %s for update: %v", id, err)
		return nil, err // Could be "user not found"
	}

	// Apply updates if new values are provided
	updated := false
	if username != nil && *username != "" && *username != user.Username {
		// Optional: Check if new username is already taken by another user
		// existingByUsername, _ := uc.userRepo.GetUserByUsername(ctx, *username)
		// if existingByUsername != nil && existingByUsername.ID != user.ID {
		// 	return nil, errors.New("username already taken")
		// }
		user.Username = *username
		updated = true
	}
	if fullName != nil && *fullName != "" && *fullName != user.FullName {
		user.FullName = *fullName
		updated = true
	}

	if !updated {
		log.Printf("No changes detected for user %s profile update.", id)
		return user, nil // Return existing user if no actual changes
	}

	// user.PrepareForUpdate() // This is called by the repository in our current setup

	updatedUser, err := uc.userRepo.UpdateUser(ctx, user)
	if err != nil {
		log.Printf("Error updating user %s in repository: %v", id, err)
		return nil, fmt.Errorf("could not update user profile: %w", err)
	}

	// Invalidate/update cache after successful DB update
	cacheErr := uc.userCache.DeleteUser(ctx, id) // Simple invalidation
	// Or: uc.userCache.SetUser(ctx, id, updatedUser, 1*time.Hour) // Update with new data
	if cacheErr != nil {
		log.Printf("Warning: Failed to invalidate/update cache for user %s after profile update: %v", id, cacheErr)
	}

	log.Printf("User profile updated successfully for ID: %s", id)
	return updatedUser, nil
}

// DeleteUser handles deleting a user.
func (uc *userUsecase) DeleteUser(ctx context.Context, id string) error {
	if id == "" {
		return errors.New("user ID is required for deletion")
	}

	err := uc.userRepo.DeleteUser(ctx, id)
	if err != nil {
		log.Printf("Error deleting user %s from repository: %v", id, err)
		return fmt.Errorf("could not delete user: %w", err)
	}

	// Invalidate cache after successful DB deletion
	cacheErr := uc.userCache.DeleteUser(ctx, id)
	if cacheErr != nil {
		log.Printf("Warning: Failed to delete user %s from cache after DB deletion: %v", id, cacheErr)
	}

	log.Printf("User deleted successfully: ID %s", id)
	return nil
}
